<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>스네이크 게임 (HTML 한 파일)</title>
  <style>
    :root {
      --bg: #0f1221;
      --panel: #171a2f;
      --accent: #6cf0a6;
      --accent-2: #62a8ff;
      --food: #ff6b6b;
      --snake: #d7f9e9;
      --snake-head: #b7ffd6;
      --grid: rgba(255,255,255,0.06);
      --text: #e6eaf2;
      --muted: #9aa3b2;
    }

    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 800px at 70% 20%, #18203a 0%, #0f1221 60%);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", "Helvetica Neue", Arial, "Apple SD Gothic Neo", "Malgun Gothic", "맑은 고딕", sans-serif;
    }

    .wrap {
      min-height: 100%;
      display: grid;
      place-items: center;
      padding: 24px;
    }

    .frame {
      width: min(92vmin, 720px);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0)) border-box, var(--panel);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 18px 18px 14px;
      box-shadow:
        0 10px 30px rgba(0,0,0,0.35),
        inset 0 0 0 1px rgba(255,255,255,0.04);
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 12px;
    }

    h1 {
      font-size: 18px;
      font-weight: 700;
      letter-spacing: 0.3px;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    h1 .dot {
      width: 10px;
      height: 10px;
      background: radial-gradient(circle at 30% 30%, var(--accent), #35b676);
      border-radius: 50%;
      box-shadow: 0 0 10px #35b676;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 8px 12px;
      flex-wrap: wrap;
    }

    .btn {
      background: linear-gradient(180deg, rgba(108, 240, 166, 0.12), rgba(108, 240, 166, 0.02));
      border: 1px solid rgba(108, 240, 166, 0.35);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      transition: transform .06s ease, box-shadow .2s ease, background .2s ease;
      user-select: none;
    }
    .btn:hover { box-shadow: 0 6px 20px rgba(108, 240, 166, 0.2); }
    .btn:active { transform: translateY(1px) scale(0.99); }
    .btn.muted {
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.14);
      color: var(--muted);
    }

    .stats {
      display: flex; gap: 10px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.2;
    }
    .stats b { color: var(--text); }

    .board {
      position: relative;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0)) border-box, var(--bg);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      padding: 10px;
    }

    /* 내부 캔버스는 논리 해상도 고정, CSS로 반응형 확대 */
    canvas {
      display: block;
      width: 100%;
      height: auto;
      image-rendering: crisp-edges;
      image-rendering: pixelated;
      border-radius: 10px;
      background: #0b0e1a;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
    }

    .hud {
      position: absolute;
      inset: 10px;
      pointer-events: none;
    }
    .hud .score {
      position: absolute;
      top: 12px; left: 12px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 8px;
      padding: 6px 10px;
      font-weight: 700;
      color: var(--accent);
      text-shadow: 0 1px 0 rgba(0,0,0,0.4);
    }
    .hud .high {
      position: absolute;
      top: 12px; right: 12px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 8px;
      padding: 6px 10px;
      font-weight: 700;
      color: var(--accent-2);
      text-shadow: 0 1px 0 rgba(0,0,0,0.4);
    }

    .overlay {
      position: absolute;
      inset: 10px;
      display: grid;
      place-items: center;
      background: radial-gradient(600px 400px at 50% 40%, rgba(0,0,0,0.35), rgba(0,0,0,0.55));
      border-radius: 10px;
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      opacity: 0;
      visibility: hidden;
      transition: opacity .2s ease, visibility .2s ease;
    }
    .overlay.show {
      opacity: 1;
      visibility: visible;
    }
    .overlay .panel {
      background: rgba(10,12,22,0.85);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 12px;
      padding: 18px 18px 14px;
      text-align: center;
      box-shadow: 0 10px 40px rgba(0,0,0,0.45);
      max-width: 90%;
    }
    .overlay h2 {
      margin: 0 0 8px;
      font-size: 22px;
    }
    .overlay p {
      margin: 6px 0 14px;
      color: var(--muted);
      font-size: 14px;
    }

    footer {
      margin-top: 10px;
      font-size: 13px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }
    code.k { background: rgba(255,255,255,0.08); padding: 2px 6px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.12); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="frame" id="frame" tabindex="0" aria-label="스네이크 게임 영역(키보드 화살표로 조작)">
      <header>
        <h1><span class="dot" aria-hidden="true"></span> 스네이크 게임</h1>
        <div class="controls">
          <button class="btn" id="restartBtn" title="다시 시작 (R)">다시 시작</button>
          <button class="btn muted" id="pauseBtn" title="일시정지/재개 (Space)">일시정지</button>
          <div class="stats">
            <span>속도: <b><span id="speedLabel">보통</span></b></span>
            <span>크기: <b>25×25</b></span>
          </div>
        </div>
      </header>

      <div class="board">
        <!-- 논리 해상도 500x500 (25칸 × 20px) -->
        <canvas id="game" width="500" height="500"></canvas>
        <div class="hud">
          <div class="score">점수: <span id="score">0</span></div>
          <div class="high">최고점수: <span id="high">0</span></div>
        </div>
        <div class="overlay" id="overlay" aria-live="polite" aria-atomic="true">
          <div class="panel">
            <h2 id="overlayTitle">게임 오버</h2>
            <p id="overlayMsg">다시 하려면 <b>R</b> 키를 누르거나 아래 버튼을 클릭하세요.</p>
            <div style="display:flex; gap:10px; justify-content:center;">
              <button class="btn" id="overlayRestart">다시 시작</button>
              <button class="btn muted" id="overlayClose">닫기</button>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div>
          조작: <code class="k">↑</code> <code class="k">↓</code> <code class="k">←</code> <code class="k">→</code>
          <span aria-hidden="true">·</span> 다시 시작: <code class="k">R</code>
          <span aria-hidden="true">·</span> 일시정지: <code class="k">Space</code>
        </div>
        <div>브라우저 창이 스크롤되지 않도록 방향키 입력 시 자동으로 차단합니다.</div>
      </footer>
    </div>
  </div>

  <script>
    // =========================
    // 스네이크 게임 (한 파일)
    // =========================

    // 캔버스 및 기본 설정
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: false });

    // 고정 논리 격자 (25x25), 타일 크기 20px => 500x500
    const TILE_SIZE = 20;
    const COLS = canvas.width / TILE_SIZE;   // 25
    const ROWS = canvas.height / TILE_SIZE;  // 25

    // UI 요소
    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('high');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayMsg = document.getElementById('overlayMsg');
    const restartBtn = document.getElementById('restartBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const overlayRestart = document.getElementById('overlayRestart');
    const overlayClose = document.getElementById('overlayClose');
    const speedLabel = document.getElementById('speedLabel');
    const frame = document.getElementById('frame');

    // 사운드 없이 조용히. 필요 시 간단한 비프 음을 추가 가능.

    // 게임 상태
    let snake = [];
    let dir = { x: 1, y: 0 };      // 현재 방향
    let nextDir = { x: 1, y: 0 };  // 입력 대기 방향 (한 틱에 1회만 반영)
    let directionLocked = false;   // 한 프레임 내 다중 방향 변경 방지
    let food = { x: 10, y: 10 };
    let score = 0;
    let high = Number(localStorage.getItem('snake_high_score') || 0);
    let isPaused = false;
    let isOver = false;

    // 속도 제어 (ms per step). 점수에 따라 interval 감소.
    const SPEEDS = {
      // 단계 레이블 및 기준 속도. 필요 시 난이도 선택 UI로 확장 가능.
      label: ['느림', '보통', '빠름'],
      base: { slow: 150, normal: 120, fast: 95 }
    };
    let baseInterval = SPEEDS.base.normal;  // 기본은 보통
    let stepInterval = baseInterval;        // 현재 진행 간격(ms)
    let lastTime = 0;
    let acc = 0;
    let rafId = null;

    // 색상
    const color = {
      bg: '#0b0e1a',
      grid: 'rgba(255,255,255,0.06)',
      food: '#ff6b6b',
      snake: '#d7f9e9',
      head: '#b7ffd6'
    };

    // 초기화
    function resetGame(showOverlay = false) {
      // 초기 길이 4, 중앙 근처에서 시작
      snake = [
        { x: 8, y: 12 },
        { x: 7, y: 12 },
        { x: 6, y: 12 },
        { x: 5, y: 12 },
      ];
      dir = { x: 1, y: 0 };
      nextDir = { x: 1, y: 0 };
      directionLocked = false;
      score = 0;
      stepInterval = baseInterval;
      isPaused = false;
      isOver = false;
      hideOverlay();
      placeFood();
      updateScoreUI();
      updateSpeedLabel();
      // 프레임 루프 재시작
      cancelAnimationFrame(rafId);
      lastTime = performance.now();
      acc = 0;
      rafId = requestAnimationFrame(loop);
    }

    // 점수 UI 업데이트
    function updateScoreUI() {
      scoreEl.textContent = String(score);
      highEl.textContent = String(high);
    }

    // 속도 레이블 대략적 표기
    function updateSpeedLabel() {
      const ms = stepInterval;
      const label =
        ms <= 100 ? '빠름' :
        ms <= 130 ? '보통' : '느림';
      speedLabel.textContent = label;
    }

    // 음식 배치 (뱀 몸통과 겹치지 않도록)
    function placeFood() {
      let x, y, conflict;
      do {
        x = Math.floor(Math.random() * COLS);
        y = Math.floor(Math.random() * ROWS);
        conflict = snake.some(seg => seg.x === x && seg.y === y);
      } while (conflict);
      food = { x, y };
    }

    // 게임 루프 (시간 축적 방식)
    function loop(ts) {
      rafId = requestAnimationFrame(loop);
      if (isPaused || isOver) return;
      const dt = ts - lastTime;
      lastTime = ts;
      acc += dt;

      if (acc >= stepInterval) {
        // 여러 프레임 누적 최소화
        while (acc >= stepInterval) acc -= stepInterval;
        step();
      }
      draw();
    }

    // 한 스텝 진행 (이동/충돌/먹이/성장)
    function step() {
      // 방향 반영(틱당 한 번)
      dir = nextDir;
      directionLocked = false;

      const head = snake[0];
      const newHead = { x: head.x + dir.x, y: head.y + dir.y };

      // 벽 충돌 (랩어라운드 X)
      if (newHead.x < 0 || newHead.x >= COLS || newHead.y < 0 || newHead.y >= ROWS) {
        return gameOver();
      }
      // 자기 몸 충돌
      for (let i = 0; i < snake.length; i++) {
        if (snake[i].x === newHead.x && snake[i].y === newHead.y) {
          return gameOver();
        }
      }

      // 이동(앞에 새 머리 추가)
      snake.unshift(newHead);

      // 먹이
      if (newHead.x === food.x && newHead.y === food.y) {
        score += 1;
        if (score > high) {
          high = score;
          localStorage.setItem('snake_high_score', String(high));
        }
        updateScoreUI();
        // 속도 소폭 증가 (최소 70ms 까지)
        stepInterval = Math.max(70, baseInterval - Math.floor(score * 2.2));
        updateSpeedLabel();
        placeFood();
      } else {
        // 꼬리 제거 (길이 유지)
        snake.pop();
      }
    }

    // 그리기
    function draw() {
      // 배경
      ctx.fillStyle = color.bg;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 그리드
      ctx.strokeStyle = color.grid;
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let x = TILE_SIZE + 0.5; x < canvas.width; x += TILE_SIZE) {
        ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height);
      }
      for (let y = TILE_SIZE + 0.5; y < canvas.height; y += TILE_SIZE) {
        ctx.moveTo(0, y); ctx.lineTo(canvas.width, y);
      }
      ctx.stroke();

      // 음식
      drawCell(food.x, food.y, color.food, true);

      // 뱀 (머리/몸 구분)
      for (let i = snake.length - 1; i >= 0; i--) {
        const seg = snake[i];
        const isHead = (i === 0);
        drawCell(seg.x, seg.y, isHead ? color.head : color.snake, false, isHead);
      }
    }

    // 한 칸 그리기 (약간 둥근 사각형)
    function drawCell(cx, cy, fill, pulse = false, isHead = false) {
      const x = cx * TILE_SIZE;
      const y = cy * TILE_SIZE;
      const r = 5; // 라운드 정도

      // 외곽
      ctx.fillStyle = fill;
      roundRect(ctx, x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2, r);
      ctx.fill();

      // 머리 하이라이트/눈
      if (isHead) {
        // 방향 기준 눈 두 개의 위치
        const eyeOffset = 4;
        const centerX = x + TILE_SIZE / 2;
        const centerY = y + TILE_SIZE / 2;
        let ex1 = 0, ey1 = 0, ex2 = 0, ey2 = 0;
        if (dir.x === 1) { // →
          ex1 = centerX + 3; ey1 = centerY - eyeOffset;
          ex2 = centerX + 3; ey2 = centerY + eyeOffset;
        } else if (dir.x === -1) { // ←
          ex1 = centerX - 3; ey1 = centerY - eyeOffset;
          ex2 = centerX - 3; ey2 = centerY + eyeOffset;
        } else if (dir.y === 1) { // ↓
          ex1 = centerX - eyeOffset; ey1 = centerY + 3;
          ex2 = centerX + eyeOffset; ey2 = centerY + 3;
        } else if (dir.y === -1) { // ↑
          ex1 = centerX - eyeOffset; ey1 = centerY - 3;
          ex2 = centerX + eyeOffset; ey2 = centerY - 3;
        }
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.beginPath(); ctx.arc(ex1, ey1, 1.8, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(ex2, ey2, 1.8, 0, Math.PI*2); ctx.fill();
      }

      // 음식 펄스 효과
      if (pulse) {
        const t = performance.now() * 0.006;
        const alpha = 0.25 + 0.15 * Math.sin(t);
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha.toFixed(3)})`;
        ctx.lineWidth = 1;
        roundRect(ctx, x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4, r);
        ctx.stroke();
      }
    }

    // 둥근 사각형 path
    function roundRect(ctx, x, y, w, h, r) {
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    // 게임 오버
    function gameOver() {
      isOver = true;
      showOverlay('게임 오버', `점수: <b>${score}</b> · 최고점수: <b>${high}</b><br>다시 시작하려면 <b>R</b> 키 또는 버튼을 눌러주세요.`);
    }

    // 오버레이
    function showOverlay(title, htmlMsg) {
      overlayTitle.textContent = title;
      overlayMsg.innerHTML = htmlMsg;
      overlay.classList.add('show');
    }
    function hideOverlay() {
      overlay.classList.remove('show');
    }

    // 입력 처리: 방향키/스페이스/R
    window.addEventListener('keydown', (e) => {
      const key = e.key;
      // 방향키/스페이스/R 입력 시 스크롤 방지
      if (key === 'ArrowUp' || key === 'ArrowDown' || key === 'ArrowLeft' || key === 'ArrowRight' || key === ' ' || key === 'Spacebar' || key === 'r' || key === 'R') {
        e.preventDefault();
      }

      if (key === 'r' || key === 'R') {
        resetGame();
        return;
      }
      if (key === ' ' || key === 'Spacebar') {
        togglePause();
        return;
      }

      // 방향 전환 (틱 당 1회, 180도 역전 금지)
      if (directionLocked) return;

      if (key === 'ArrowUp') setDirection(0, -1);
      else if (key === 'ArrowDown') setDirection(0, 1);
      else if (key === 'ArrowLeft') setDirection(-1, 0);
      else if (key === 'ArrowRight') setDirection(1, 0);
    }, { passive: false });

    function setDirection(x, y) {
      // 역방향 방지
      if (x + dir.x === 0 && y + dir.y === 0) return;
      nextDir = { x, y };
      directionLocked = true;
    }

    function togglePause() {
      if (isOver) return;
      isPaused = !isPaused;
      pauseBtn.textContent = isPaused ? '재개' : '일시정지';
      if (!isPaused) {
        // 일시정지 해제 시 타이밍 초기화
        lastTime = performance.now();
        acc = 0;
      }
    }

    // 버튼 이벤트
    restartBtn.addEventListener('click', () => resetGame());
    overlayRestart.addEventListener('click', () => resetGame());
    overlayClose.addEventListener('click', () => hideOverlay());
    pauseBtn.addEventListener('click', () => togglePause());

    // 초기 최고점수 표시
    highEl.textContent = String(high);

    // 포커스 편의: 프레임 클릭 시 키 입력 가능
    frame.addEventListener('click', () => frame.focus());
    // 자동 포커스 (모바일 브라우저에서는 무시될 수 있음)
    setTimeout(() => frame.focus(), 50);

    // 시작
    resetGame(/*showOverlay*/ false);
  </script>
</body>
</html>
